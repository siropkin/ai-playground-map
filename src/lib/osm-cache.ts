import { MapBounds } from "@/types/map";
import { OSMQueryResults } from "@/types/osm";
import { createClient } from "@/lib/supabase/server";

// Cache configuration
const OSM_CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours
const OSM_CACHE_TABLE_NAME = "osm_query_cache";
const MAX_CACHE_ENTRIES = 10000; // LRU eviction threshold

/**
 * Generates a cache key for OSM queries based on quantized bounding box and zoom level.
 * Quantization reduces cache fragmentation by grouping similar queries together.
 *
 * @param bounds - Map bounding box
 * @param zoom - Current zoom level
 * @returns Cache key string
 */
export function generateOSMCacheKey(bounds: MapBounds, zoom: number): string {
  // Quantize coordinates based on zoom level
  // Higher zoom = higher precision (more decimal places)
  // Lower zoom = lower precision (fewer decimal places, more cache hits)
  const precision = Math.max(2, 6 - Math.floor(zoom / 3));

  const north = bounds.north.toFixed(precision);
  const south = bounds.south.toFixed(precision);
  const east = bounds.east.toFixed(precision);
  const west = bounds.west.toFixed(precision);
  const zoomBucket = Math.floor(zoom); // Group by integer zoom

  return `osm:${north}:${south}:${east}:${west}:${zoomBucket}`;
}

/**
 * Checks if a cache entry has expired based on TTL.
 *
 * @param createdAt - ISO timestamp of cache creation
 * @returns True if cache has expired
 */
function isCacheExpired(createdAt: string): boolean {
  const now = Date.now();
  const created = new Date(createdAt).getTime();
  return now - created > OSM_CACHE_TTL_MS;
}

/**
 * Fetches OSM query results from cache.
 *
 * @param cacheKey - Cache key generated by generateOSMCacheKey
 * @returns Cached playgrounds or null if cache miss/expired
 */
export async function fetchOSMFromCache(
  cacheKey: string
): Promise<OSMQueryResults[] | null> {
  try {
    const supabase = await createClient();

    const { data, error } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("playgrounds, created_at, query_count")
      .eq("cache_key", cacheKey)
      .single();

    if (error || !data) {
      console.log(`[OSM Cache] Miss: ${cacheKey}`);
      return null;
    }

    // Check if cache has expired
    if (isCacheExpired(data.created_at)) {
      console.log(`[OSM Cache] Expired: ${cacheKey}`);
      // Delete expired entry
      await supabase
        .from(OSM_CACHE_TABLE_NAME)
        .delete()
        .eq("cache_key", cacheKey);

      return null;
    }

    // Update access time and query count for LRU tracking
    await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .update({
        last_accessed_at: new Date().toISOString(),
        query_count: data.query_count + 1
      })
      .eq("cache_key", cacheKey);

    const playgroundCount = (data.playgrounds as OSMQueryResults[]).length;
    console.log(`[OSM Cache] Hit: ${cacheKey} (${playgroundCount} playgrounds, accessed ${data.query_count + 1} times)`);

    return data.playgrounds as OSMQueryResults[];
  } catch (error) {
    console.error("[OSM Cache] Error fetching from cache:", error);
    return null;
  }
}

/**
 * Saves OSM query results to cache.
 *
 * @param cacheKey - Cache key generated by generateOSMCacheKey
 * @param bounds - Map bounding box
 * @param zoom - Current zoom level
 * @param playgrounds - OSM query results to cache
 */
export async function saveOSMToCache(
  cacheKey: string,
  bounds: MapBounds,
  zoom: number,
  playgrounds: OSMQueryResults[]
): Promise<void> {
  try {
    const supabase = await createClient();

    // Upsert cache entry
    const { error } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .upsert({
        cache_key: cacheKey,
        bounds: JSON.stringify(bounds),
        zoom_level: Math.floor(zoom),
        playgrounds: JSON.stringify(playgrounds),
        query_count: 1,
        created_at: new Date().toISOString(),
        last_accessed_at: new Date().toISOString()
      }, { onConflict: "cache_key" });

    if (error) {
      console.error("[OSM Cache] Failed to save cache entry:", {
        error: error.message,
        code: error.code,
        details: error.details,
        hint: error.hint,
        cacheKey
      });
      return;
    }

    console.log(`[OSM Cache] Saved entry: ${cacheKey} (${playgrounds.length} playgrounds)`);

    // Trigger LRU eviction if cache is too large (async, non-blocking)
    evictLRUIfNeeded().catch(err =>
      console.error("[OSM Cache] Error evicting LRU cache:", err)
    );
  } catch (error) {
    // Don't throw - cache failures shouldn't break the app
    console.error("[OSM Cache] Error saving OSM to cache:", error);
  }
}

/**
 * Evicts least recently used cache entries if cache exceeds max size.
 * Runs asynchronously to avoid blocking the main query.
 */
async function evictLRUIfNeeded(): Promise<void> {
  try {
    const supabase = await createClient();

    // Check cache size
    const { count } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("*", { count: "exact", head: true });

    if (!count || count <= MAX_CACHE_ENTRIES) {
      return;
    }

    // Calculate how many entries to evict (10% buffer)
    const entriesToEvict = count - Math.floor(MAX_CACHE_ENTRIES * 0.9);

    // Get least recently used entries
    const { data: lruEntries } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("cache_key")
      .order("last_accessed_at", { ascending: true })
      .limit(entriesToEvict);

    if (!lruEntries || lruEntries.length === 0) {
      return;
    }

    // Delete LRU entries
    const keysToDelete = lruEntries.map(entry => entry.cache_key);
    await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .delete()
      .in("cache_key", keysToDelete);

    console.log(`Evicted ${keysToDelete.length} LRU OSM cache entries`);
  } catch (error) {
    console.error("Error in LRU eviction:", error);
  }
}

/**
 * Clears all OSM cache entries (admin function).
 */
export async function clearAllOSMCache(): Promise<void> {
  try {
    const supabase = await createClient();
    await supabase.from(OSM_CACHE_TABLE_NAME).delete().neq("cache_key", "");
  } catch (error) {
    console.error("Error clearing OSM cache:", error);
    throw error;
  }
}

/**
 * Gets cache statistics for monitoring.
 */
export async function getOSMCacheStats() {
  try {
    const supabase = await createClient();

    const { count: totalEntries } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("*", { count: "exact", head: true });

    const { data: topQueries } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("cache_key, query_count, zoom_level")
      .order("query_count", { ascending: false })
      .limit(10);

    const { data: oldestEntry } = await supabase
      .from(OSM_CACHE_TABLE_NAME)
      .select("created_at")
      .order("created_at", { ascending: true })
      .limit(1)
      .single();

    return {
      totalEntries: totalEntries || 0,
      maxEntries: MAX_CACHE_ENTRIES,
      utilizationPercent: totalEntries ? (totalEntries / MAX_CACHE_ENTRIES * 100).toFixed(1) : 0,
      topQueries: topQueries || [],
      oldestCacheAge: oldestEntry ?
        Math.floor((Date.now() - new Date(oldestEntry.created_at).getTime()) / 1000 / 60 / 60) : 0 // hours
    };
  } catch (error) {
    console.error("Error fetching OSM cache stats:", error);
    return null;
  }
}
